{"mappings":"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","sources":["<anon>","src/background.js","src/ezrevenue.js","node_modules/jose/dist/webapi/jwt/verify.js","node_modules/jose/dist/webapi/jws/compact/verify.js","node_modules/jose/dist/webapi/jws/flattened/verify.js","node_modules/jose/dist/webapi/util/base64url.js","node_modules/jose/dist/webapi/lib/buffer_utils.js","node_modules/jose/dist/webapi/lib/base64.js","node_modules/jose/dist/webapi/lib/verify.js","node_modules/jose/dist/webapi/lib/subtle_dsa.js","node_modules/jose/dist/webapi/util/errors.js","node_modules/jose/dist/webapi/lib/check_key_length.js","node_modules/jose/dist/webapi/lib/get_sign_verify_key.js","node_modules/jose/dist/webapi/lib/crypto_key.js","node_modules/jose/dist/webapi/lib/invalid_key_input.js","node_modules/jose/dist/webapi/lib/is_disjoint.js","node_modules/jose/dist/webapi/lib/is_object.js","node_modules/jose/dist/webapi/lib/check_key_type.js","node_modules/jose/dist/webapi/lib/is_key_like.js","node_modules/jose/dist/webapi/lib/is_jwk.js","node_modules/jose/dist/webapi/lib/validate_crit.js","node_modules/jose/dist/webapi/lib/validate_algorithms.js","node_modules/jose/dist/webapi/lib/normalize_key.js","node_modules/jose/dist/webapi/lib/jwk_to_key.js","node_modules/jose/dist/webapi/lib/jwt_claims_set.js","node_modules/jose/dist/webapi/lib/epoch.js","node_modules/jose/dist/webapi/lib/secs.js","node_modules/jose/dist/webapi/jwt/sign.js","node_modules/jose/dist/webapi/jws/compact/sign.js","node_modules/jose/dist/webapi/jws/flattened/sign.js","node_modules/jose/dist/webapi/lib/sign.js","src/stringRandom.js"],"sourcesContent":["const $1e53c4773f96b7ed$export$5486af06137bf21a = new TextEncoder();\nconst $1e53c4773f96b7ed$export$124c96e6ce37090b = new TextDecoder();\nconst $1e53c4773f96b7ed$var$MAX_INT32 = 2 ** 32;\nfunction $1e53c4773f96b7ed$export$ee1b3e54f0441b22(...buffers) {\n    const size = buffers.reduce((acc, { length: length })=>acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers){\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction $1e53c4773f96b7ed$var$writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= $1e53c4773f96b7ed$var$MAX_INT32) throw new RangeError(`value must be >= 0 and <= ${$1e53c4773f96b7ed$var$MAX_INT32 - 1}. Received ${value}`);\n    buf.set([\n        value >>> 24,\n        value >>> 16,\n        value >>> 8,\n        value & 0xff\n    ], offset);\n}\nfunction $1e53c4773f96b7ed$export$e7b531e00a18fdd7(value) {\n    const high = Math.floor(value / $1e53c4773f96b7ed$var$MAX_INT32);\n    const low = value % $1e53c4773f96b7ed$var$MAX_INT32;\n    const buf = new Uint8Array(8);\n    $1e53c4773f96b7ed$var$writeUInt32BE(buf, high, 0);\n    $1e53c4773f96b7ed$var$writeUInt32BE(buf, low, 4);\n    return buf;\n}\nfunction $1e53c4773f96b7ed$export$74c16dba6c885532(value) {\n    const buf = new Uint8Array(4);\n    $1e53c4773f96b7ed$var$writeUInt32BE(buf, value);\n    return buf;\n}\n\n\nfunction $a5dc07c212020978$export$8fb536984ec8b4d7(input) {\n    if (Uint8Array.prototype.toBase64) return input.toBase64();\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for(let i = 0; i < input.length; i += CHUNK_SIZE)arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    return btoa(arr.join(''));\n}\nfunction $a5dc07c212020978$export$94fdf11bafc8de6b(encoded) {\n    if (Uint8Array.fromBase64) return Uint8Array.fromBase64(encoded);\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++)bytes[i] = binary.charCodeAt(i);\n    return bytes;\n}\n\n\nfunction $e4060018315ad9ee$export$2f872c0f2117be69(input) {\n    if (Uint8Array.fromBase64) return Uint8Array.fromBase64(typeof input === 'string' ? input : (0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(input), {\n        alphabet: 'base64url'\n    });\n    let encoded = input;\n    if (encoded instanceof Uint8Array) encoded = (0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(encoded);\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return (0, $a5dc07c212020978$export$94fdf11bafc8de6b)(encoded);\n    } catch  {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nfunction $e4060018315ad9ee$export$c564cdbbe6da493(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') unencoded = (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode(unencoded);\n    if (Uint8Array.prototype.toBase64) return unencoded.toBase64({\n        alphabet: 'base64url',\n        omitPadding: true\n    });\n    return (0, $a5dc07c212020978$export$8fb536984ec8b4d7)(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\n\nclass $fcb0a4d5ffcfa358$export$f754d6850d76bf87 extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass $fcb0a4d5ffcfa358$export$f1e14efb908196e9 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified'){\n        super(message, {\n            cause: {\n                claim: claim,\n                reason: reason,\n                payload: payload\n            }\n        });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nclass $fcb0a4d5ffcfa358$export$4b386bf852b7863d extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified'){\n        super(message, {\n            cause: {\n                claim: claim,\n                reason: reason,\n                payload: payload\n            }\n        });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nclass $fcb0a4d5ffcfa358$export$d51fd7fedeccc338 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nclass $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nclass $fcb0a4d5ffcfa358$export$1a57512ad9773b2a extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options){\n        super(message, options);\n    }\n}\nclass $fcb0a4d5ffcfa358$export$19f281f2275f6a15 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nclass $fcb0a4d5ffcfa358$export$e838de724af3d116 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nclass $fcb0a4d5ffcfa358$export$936b39ada0bbfceb extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nclass $fcb0a4d5ffcfa358$export$b3992e0f88fb07e3 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nclass $fcb0a4d5ffcfa358$export$9b22c2a1e2403b8e extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nclass $fcb0a4d5ffcfa358$export$3d5ed1a538bed04e extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options){\n        super(message, options);\n    }\n}\nclass $fcb0a4d5ffcfa358$export$dc036de401a5c284 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options){\n        super(message, options);\n    }\n}\nclass $fcb0a4d5ffcfa358$export$3f30acebf25c04e6 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options){\n        super(message, options);\n    }\n}\nclass $fcb0a4d5ffcfa358$export$c67a0218e7c50378 extends $fcb0a4d5ffcfa358$export$f754d6850d76bf87 {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options){\n        super(message, options);\n    }\n}\n\n\nvar $b931fa48b21a7ebb$export$2e2bcd8739ae039 = (alg, algorithm)=>{\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch(alg){\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return {\n                hash: hash,\n                name: 'HMAC'\n            };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return {\n                hash: hash,\n                name: 'RSA-PSS',\n                saltLength: parseInt(alg.slice(-3), 10) >> 3\n            };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return {\n                hash: hash,\n                name: 'RSASSA-PKCS1-v1_5'\n            };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return {\n                hash: hash,\n                name: 'ECDSA',\n                namedCurve: algorithm.namedCurve\n            };\n        case 'Ed25519':\n        case 'EdDSA':\n            return {\n                name: 'Ed25519'\n            };\n        default:\n            throw new (0, $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28)(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n};\n\n\nvar $a0928e387ca12497$export$2e2bcd8739ae039 = (alg, key)=>{\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength: modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n    }\n};\n\n\nfunction $9bc1a6ef4e16e750$var$unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction $9bc1a6ef4e16e750$var$isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction $9bc1a6ef4e16e750$var$getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction $9bc1a6ef4e16e750$var$getNamedCurve(alg) {\n    switch(alg){\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction $9bc1a6ef4e16e750$var$checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n}\nfunction $9bc1a6ef4e16e750$export$39a36029eee6729(key, alg, usage) {\n    switch(alg){\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'HMAC')) throw $9bc1a6ef4e16e750$var$unusable('HMAC');\n                const expected = parseInt(alg.slice(2), 10);\n                const actual = $9bc1a6ef4e16e750$var$getHashLength(key.algorithm.hash);\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(`SHA-${expected}`, 'algorithm.hash');\n                break;\n            }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5')) throw $9bc1a6ef4e16e750$var$unusable('RSASSA-PKCS1-v1_5');\n                const expected = parseInt(alg.slice(2), 10);\n                const actual = $9bc1a6ef4e16e750$var$getHashLength(key.algorithm.hash);\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(`SHA-${expected}`, 'algorithm.hash');\n                break;\n            }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'RSA-PSS')) throw $9bc1a6ef4e16e750$var$unusable('RSA-PSS');\n                const expected = parseInt(alg.slice(2), 10);\n                const actual = $9bc1a6ef4e16e750$var$getHashLength(key.algorithm.hash);\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(`SHA-${expected}`, 'algorithm.hash');\n                break;\n            }\n        case 'Ed25519':\n        case 'EdDSA':\n            if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'Ed25519')) throw $9bc1a6ef4e16e750$var$unusable('Ed25519');\n            break;\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'ECDSA')) throw $9bc1a6ef4e16e750$var$unusable('ECDSA');\n                const expected = $9bc1a6ef4e16e750$var$getNamedCurve(alg);\n                const actual = key.algorithm.namedCurve;\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(expected, 'algorithm.namedCurve');\n                break;\n            }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    $9bc1a6ef4e16e750$var$checkUsage(key, usage);\n}\nfunction $9bc1a6ef4e16e750$export$41a67f89f6678b35(key, alg, usage) {\n    switch(alg){\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'AES-GCM')) throw $9bc1a6ef4e16e750$var$unusable('AES-GCM');\n                const expected = parseInt(alg.slice(1, 4), 10);\n                const actual = key.algorithm.length;\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(expected, 'algorithm.length');\n                break;\n            }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'AES-KW')) throw $9bc1a6ef4e16e750$var$unusable('AES-KW');\n                const expected = parseInt(alg.slice(1, 4), 10);\n                const actual = key.algorithm.length;\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(expected, 'algorithm.length');\n                break;\n            }\n        case 'ECDH':\n            switch(key.algorithm.name){\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw $9bc1a6ef4e16e750$var$unusable('ECDH or X25519');\n            }\n            break;\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'PBKDF2')) throw $9bc1a6ef4e16e750$var$unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            {\n                if (!$9bc1a6ef4e16e750$var$isAlgorithm(key.algorithm, 'RSA-OAEP')) throw $9bc1a6ef4e16e750$var$unusable('RSA-OAEP');\n                const expected = parseInt(alg.slice(9), 10) || 1;\n                const actual = $9bc1a6ef4e16e750$var$getHashLength(key.algorithm.hash);\n                if (actual !== expected) throw $9bc1a6ef4e16e750$var$unusable(`SHA-${expected}`, 'algorithm.hash');\n                break;\n            }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    $9bc1a6ef4e16e750$var$checkUsage(key, usage);\n}\n\n\nfunction $abe2cc4bd17085c3$var$message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    } else if (types.length === 2) msg += `one of type ${types[0]} or ${types[1]}.`;\n    else msg += `of type ${types[0]}.`;\n    if (actual == null) msg += ` Received ${actual}`;\n    else if (typeof actual === 'function' && actual.name) msg += ` Received function ${actual.name}`;\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) msg += ` Received an instance of ${actual.constructor.name}`;\n    }\n    return msg;\n}\nvar $abe2cc4bd17085c3$export$2e2bcd8739ae039 = (actual, ...types)=>{\n    return $abe2cc4bd17085c3$var$message('Key must be ', actual, ...types);\n};\nfunction $abe2cc4bd17085c3$export$e94f758d09bc1828(alg, actual, ...types) {\n    return $abe2cc4bd17085c3$var$message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n\n\nvar $808a0a0b4110568f$export$2e2bcd8739ae039 = async (alg, key, usage)=>{\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) throw new TypeError((0, $abe2cc4bd17085c3$export$2e2bcd8739ae039)(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        return crypto.subtle.importKey('raw', key, {\n            hash: `SHA-${alg.slice(-3)}`,\n            name: 'HMAC'\n        }, false, [\n            usage\n        ]);\n    }\n    (0, $9bc1a6ef4e16e750$export$39a36029eee6729)(key, alg, usage);\n    return key;\n};\n\n\nvar $3020225b8bd97811$export$2e2bcd8739ae039 = async (alg, key, signature, data)=>{\n    const cryptoKey = await (0, $808a0a0b4110568f$export$2e2bcd8739ae039)(alg, key, 'verify');\n    (0, $a0928e387ca12497$export$2e2bcd8739ae039)(alg, cryptoKey);\n    const algorithm = (0, $b931fa48b21a7ebb$export$2e2bcd8739ae039)(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    } catch  {\n        return false;\n    }\n};\n\n\n\n\nvar $d4e8ade71e394405$export$2e2bcd8739ae039 = (...headers)=>{\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) return true;\n    let acc;\n    for (const header of sources){\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters){\n            if (acc.has(parameter)) return false;\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n\n\nfunction $d42659f8a5b8d03b$var$isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nvar $d42659f8a5b8d03b$export$2e2bcd8739ae039 = (input)=>{\n    if (!$d42659f8a5b8d03b$var$isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') return false;\n    if (Object.getPrototypeOf(input) === null) return true;\n    let proto = input;\n    while(Object.getPrototypeOf(proto) !== null)proto = Object.getPrototypeOf(proto);\n    return Object.getPrototypeOf(input) === proto;\n};\n\n\n\nfunction $b5aa186e9118266c$export$af46c52e955d1475(key) {\n    if (!$b5aa186e9118266c$export$600b5603bbac4c6(key)) throw new Error('CryptoKey instance expected');\n}\nfunction $b5aa186e9118266c$export$600b5603bbac4c6(key) {\n    return key?.[Symbol.toStringTag] === 'CryptoKey';\n}\nfunction $b5aa186e9118266c$export$5c7abba3d2afc0b8(key) {\n    return key?.[Symbol.toStringTag] === 'KeyObject';\n}\nvar $b5aa186e9118266c$export$2e2bcd8739ae039 = (key)=>{\n    return $b5aa186e9118266c$export$600b5603bbac4c6(key) || $b5aa186e9118266c$export$5c7abba3d2afc0b8(key);\n};\n\n\n\nfunction $1635c73958ea941f$export$9a44c2ef7e3b3dad(key) {\n    return (0, $d42659f8a5b8d03b$export$2e2bcd8739ae039)(key) && typeof key.kty === 'string';\n}\nfunction $1635c73958ea941f$export$431699a4f17ba0e(key) {\n    return key.kty !== 'oct' && typeof key.d === 'string';\n}\nfunction $1635c73958ea941f$export$b786616db1cddf3(key) {\n    return key.kty !== 'oct' && typeof key.d === 'undefined';\n}\nfunction $1635c73958ea941f$export$f8ecf533504bc7ad(key) {\n    return key.kty === 'oct' && typeof key.k === 'string';\n}\n\n\nconst $4de7699679ffccc9$var$tag = (key)=>key?.[Symbol.toStringTag];\nconst $4de7699679ffccc9$var$jwkMatchesOp = (alg, key, usage)=>{\n    if (key.use !== undefined) {\n        let expected;\n        switch(usage){\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n    }\n    if (key.alg !== undefined && key.alg !== alg) throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch(true){\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                else expectedKeyOp = usage;\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n    }\n    return true;\n};\nconst $4de7699679ffccc9$var$symmetricTypeCheck = (alg, key, usage)=>{\n    if (key instanceof Uint8Array) return;\n    if ($1635c73958ea941f$export$9a44c2ef7e3b3dad(key)) {\n        if ($1635c73958ea941f$export$f8ecf533504bc7ad(key) && $4de7699679ffccc9$var$jwkMatchesOp(alg, key, usage)) return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!(0, $b5aa186e9118266c$export$2e2bcd8739ae039)(key)) throw new TypeError((0, $abe2cc4bd17085c3$export$e94f758d09bc1828)(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    if (key.type !== 'secret') throw new TypeError(`${$4de7699679ffccc9$var$tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n};\nconst $4de7699679ffccc9$var$asymmetricTypeCheck = (alg, key, usage)=>{\n    if ($1635c73958ea941f$export$9a44c2ef7e3b3dad(key)) switch(usage){\n        case 'decrypt':\n        case 'sign':\n            if ($1635c73958ea941f$export$431699a4f17ba0e(key) && $4de7699679ffccc9$var$jwkMatchesOp(alg, key, usage)) return;\n            throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n        case 'encrypt':\n        case 'verify':\n            if ($1635c73958ea941f$export$b786616db1cddf3(key) && $4de7699679ffccc9$var$jwkMatchesOp(alg, key, usage)) return;\n            throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n    }\n    if (!(0, $b5aa186e9118266c$export$2e2bcd8739ae039)(key)) throw new TypeError((0, $abe2cc4bd17085c3$export$e94f758d09bc1828)(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    if (key.type === 'secret') throw new TypeError(`${$4de7699679ffccc9$var$tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    if (key.type === 'public') switch(usage){\n        case 'sign':\n            throw new TypeError(`${$4de7699679ffccc9$var$tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n        case 'decrypt':\n            throw new TypeError(`${$4de7699679ffccc9$var$tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n        default:\n            break;\n    }\n    if (key.type === 'private') switch(usage){\n        case 'verify':\n            throw new TypeError(`${$4de7699679ffccc9$var$tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n        case 'encrypt':\n            throw new TypeError(`${$4de7699679ffccc9$var$tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n        default:\n            break;\n    }\n};\nvar $4de7699679ffccc9$export$2e2bcd8739ae039 = (alg, key, usage)=>{\n    const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(alg) || /^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(alg);\n    if (symmetric) $4de7699679ffccc9$var$symmetricTypeCheck(alg, key, usage);\n    else $4de7699679ffccc9$var$asymmetricTypeCheck(alg, key, usage);\n};\n\n\n\nvar $0feff00fbaa58163$export$2e2bcd8739ae039 = (Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader)=>{\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    if (!protectedHeader || protectedHeader.crit === undefined) return new Set();\n    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== 'string' || input.length === 0)) throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    let recognized;\n    if (recognizedOption !== undefined) recognized = new Map([\n        ...Object.entries(recognizedOption),\n        ...recognizedDefault.entries()\n    ]);\n    else recognized = recognizedDefault;\n    for (const parameter of protectedHeader.crit){\n        if (!recognized.has(parameter)) throw new (0, $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28)(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        if (joseHeader[parameter] === undefined) throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n    }\n    return new Set(protectedHeader.crit);\n};\n\n\nvar $7001990ad23a4387$export$2e2bcd8739ae039 = (option, algorithms)=>{\n    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s)=>typeof s !== 'string'))) throw new TypeError(`\"${option}\" option must be an array of strings`);\n    if (!algorithms) return undefined;\n    return new Set(algorithms);\n};\n\n\n\n\n\nfunction $8c122fdfc9a37024$var$subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch(jwk.kty){\n        case 'RSA':\n            switch(jwk.alg){\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = {\n                        name: 'RSA-PSS',\n                        hash: `SHA-${jwk.alg.slice(-3)}`\n                    };\n                    keyUsages = jwk.d ? [\n                        'sign'\n                    ] : [\n                        'verify'\n                    ];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = {\n                        name: 'RSASSA-PKCS1-v1_5',\n                        hash: `SHA-${jwk.alg.slice(-3)}`\n                    };\n                    keyUsages = jwk.d ? [\n                        'sign'\n                    ] : [\n                        'verify'\n                    ];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`\n                    };\n                    keyUsages = jwk.d ? [\n                        'decrypt',\n                        'unwrapKey'\n                    ] : [\n                        'encrypt',\n                        'wrapKey'\n                    ];\n                    break;\n                default:\n                    throw new (0, $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28)('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        case 'EC':\n            switch(jwk.alg){\n                case 'ES256':\n                    algorithm = {\n                        name: 'ECDSA',\n                        namedCurve: 'P-256'\n                    };\n                    keyUsages = jwk.d ? [\n                        'sign'\n                    ] : [\n                        'verify'\n                    ];\n                    break;\n                case 'ES384':\n                    algorithm = {\n                        name: 'ECDSA',\n                        namedCurve: 'P-384'\n                    };\n                    keyUsages = jwk.d ? [\n                        'sign'\n                    ] : [\n                        'verify'\n                    ];\n                    break;\n                case 'ES512':\n                    algorithm = {\n                        name: 'ECDSA',\n                        namedCurve: 'P-521'\n                    };\n                    keyUsages = jwk.d ? [\n                        'sign'\n                    ] : [\n                        'verify'\n                    ];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = {\n                        name: 'ECDH',\n                        namedCurve: jwk.crv\n                    };\n                    keyUsages = jwk.d ? [\n                        'deriveBits'\n                    ] : [];\n                    break;\n                default:\n                    throw new (0, $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28)('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        case 'OKP':\n            switch(jwk.alg){\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = {\n                        name: 'Ed25519'\n                    };\n                    keyUsages = jwk.d ? [\n                        'sign'\n                    ] : [\n                        'verify'\n                    ];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = {\n                        name: jwk.crv\n                    };\n                    keyUsages = jwk.d ? [\n                        'deriveBits'\n                    ] : [];\n                    break;\n                default:\n                    throw new (0, $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28)('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        default:\n            throw new (0, $fcb0a4d5ffcfa358$export$19ddbcbf2016ab28)('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return {\n        algorithm: algorithm,\n        keyUsages: keyUsages\n    };\n}\nvar $8c122fdfc9a37024$export$2e2bcd8739ae039 = async (jwk)=>{\n    if (!jwk.alg) throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    const { algorithm: algorithm, keyUsages: keyUsages } = $8c122fdfc9a37024$var$subtleMapping(jwk);\n    const keyData = {\n        ...jwk\n    };\n    delete keyData.alg;\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d ? false : true), jwk.key_ops ?? keyUsages);\n};\n\n\n\nlet $cfbcd9d6853dac90$var$cache;\nconst $cfbcd9d6853dac90$var$handleJWK = async (key, jwk, alg, freeze = false)=>{\n    $cfbcd9d6853dac90$var$cache ||= new WeakMap();\n    let cached = $cfbcd9d6853dac90$var$cache.get(key);\n    if (cached?.[alg]) return cached[alg];\n    const cryptoKey = await (0, $8c122fdfc9a37024$export$2e2bcd8739ae039)({\n        ...jwk,\n        alg: alg\n    });\n    if (freeze) Object.freeze(key);\n    if (!cached) $cfbcd9d6853dac90$var$cache.set(key, {\n        [alg]: cryptoKey\n    });\n    else cached[alg] = cryptoKey;\n    return cryptoKey;\n};\nconst $cfbcd9d6853dac90$var$handleKeyObject = (keyObject, alg)=>{\n    $cfbcd9d6853dac90$var$cache ||= new WeakMap();\n    let cached = $cfbcd9d6853dac90$var$cache.get(keyObject);\n    if (cached?.[alg]) return cached[alg];\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch(alg){\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : [\n            'deriveBits'\n        ]);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign'\n        ]);\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch(alg){\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) return keyObject.toCryptoKey({\n            name: 'RSA-OAEP',\n            hash: hash\n        }, extractable, isPublic ? [\n            'encrypt'\n        ] : [\n            'decrypt'\n        ]);\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash: hash\n        }, extractable, [\n            isPublic ? 'verify' : 'sign'\n        ]);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            [\n                'prime256v1',\n                'P-256'\n            ],\n            [\n                'secp384r1',\n                'P-384'\n            ],\n            [\n                'secp521r1',\n                'P-521'\n            ]\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        if (alg === 'ES256' && namedCurve === 'P-256') cryptoKey = keyObject.toCryptoKey({\n            name: 'ECDSA',\n            namedCurve: namedCurve\n        }, extractable, [\n            isPublic ? 'verify' : 'sign'\n        ]);\n        if (alg === 'ES384' && namedCurve === 'P-384') cryptoKey = keyObject.toCryptoKey({\n            name: 'ECDSA',\n            namedCurve: namedCurve\n        }, extractable, [\n            isPublic ? 'verify' : 'sign'\n        ]);\n        if (alg === 'ES512' && namedCurve === 'P-521') cryptoKey = keyObject.toCryptoKey({\n            name: 'ECDSA',\n            namedCurve: namedCurve\n        }, extractable, [\n            isPublic ? 'verify' : 'sign'\n        ]);\n        if (alg.startsWith('ECDH-ES')) cryptoKey = keyObject.toCryptoKey({\n            name: 'ECDH',\n            namedCurve: namedCurve\n        }, extractable, isPublic ? [] : [\n            'deriveBits'\n        ]);\n    }\n    if (!cryptoKey) throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    if (!cached) $cfbcd9d6853dac90$var$cache.set(keyObject, {\n        [alg]: cryptoKey\n    });\n    else cached[alg] = cryptoKey;\n    return cryptoKey;\n};\nvar $cfbcd9d6853dac90$export$2e2bcd8739ae039 = async (key, alg)=>{\n    if (key instanceof Uint8Array) return key;\n    if ((0, $b5aa186e9118266c$export$600b5603bbac4c6)(key)) return key;\n    if ((0, $b5aa186e9118266c$export$5c7abba3d2afc0b8)(key)) {\n        if (key.type === 'secret') return key.export();\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') try {\n            return $cfbcd9d6853dac90$var$handleKeyObject(key, alg);\n        } catch (err) {\n            if (err instanceof TypeError) throw err;\n        }\n        let jwk = key.export({\n            format: 'jwk'\n        });\n        return $cfbcd9d6853dac90$var$handleJWK(key, jwk, alg);\n    }\n    if ((0, $1635c73958ea941f$export$9a44c2ef7e3b3dad)(key)) {\n        if (key.k) return (0, $e4060018315ad9ee$export$2f872c0f2117be69)(key.k);\n        return $cfbcd9d6853dac90$var$handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n};\n\n\nasync function $0ba0dc1bfe5ab4e3$export$b2614975507c40c9(jws, key, options) {\n    if (!(0, $d42659f8a5b8d03b$export$2e2bcd8739ae039)(jws)) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('Flattened JWS must be an object');\n    if (jws.protected === undefined && jws.header === undefined) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Protected Header incorrect type');\n    if (jws.payload === undefined) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Payload missing');\n    if (typeof jws.signature !== 'string') throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Signature missing or incorrect type');\n    if (jws.header !== undefined && !(0, $d42659f8a5b8d03b$export$2e2bcd8739ae039)(jws.header)) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Unprotected Header incorrect type');\n    let parsedProt = {};\n    if (jws.protected) try {\n        const protectedHeader = (0, $e4060018315ad9ee$export$2f872c0f2117be69)(jws.protected);\n        parsedProt = JSON.parse((0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(protectedHeader));\n    } catch  {\n        throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Protected Header is invalid');\n    }\n    if (!(0, $d4e8ade71e394405$export$2e2bcd8739ae039)(parsedProt, jws.header)) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header\n    };\n    const extensions = (0, $0feff00fbaa58163$export$2e2bcd8739ae039)((0, $fcb0a4d5ffcfa358$export$e838de724af3d116), new Map([\n        [\n            'b64',\n            true\n        ]\n    ]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n    }\n    const { alg: alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    const algorithms = options && (0, $7001990ad23a4387$export$2e2bcd8739ae039)('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) throw new (0, $fcb0a4d5ffcfa358$export$d51fd7fedeccc338)('\"alg\" (Algorithm) Header Parameter value not allowed');\n    if (b64) {\n        if (typeof jws.payload !== 'string') throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Payload must be a string');\n    } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Payload must be a string or an Uint8Array instance');\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    (0, $4de7699679ffccc9$export$2e2bcd8739ae039)(alg, key, 'verify');\n    const data = (0, $1e53c4773f96b7ed$export$ee1b3e54f0441b22)((0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode(jws.protected ?? ''), (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode('.'), typeof jws.payload === 'string' ? (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = (0, $e4060018315ad9ee$export$2f872c0f2117be69)(jws.signature);\n    } catch  {\n        throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('Failed to base64url decode the signature');\n    }\n    const k = await (0, $cfbcd9d6853dac90$export$2e2bcd8739ae039)(key, alg);\n    const verified = await (0, $3020225b8bd97811$export$2e2bcd8739ae039)(alg, k, signature, data);\n    if (!verified) throw new (0, $fcb0a4d5ffcfa358$export$c67a0218e7c50378)();\n    let payload;\n    if (b64) try {\n        payload = (0, $e4060018315ad9ee$export$2f872c0f2117be69)(jws.payload);\n    } catch  {\n        throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('Failed to base64url decode the payload');\n    }\n    else if (typeof jws.payload === 'string') payload = (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode(jws.payload);\n    else payload = jws.payload;\n    const result = {\n        payload: payload\n    };\n    if (jws.protected !== undefined) result.protectedHeader = parsedProt;\n    if (jws.header !== undefined) result.unprotectedHeader = jws.header;\n    if (resolvedKey) return {\n        ...result,\n        key: k\n    };\n    return result;\n}\n\n\n\n\nasync function $34b21a43c46da8fc$export$996150e72a8992e(jws, key, options) {\n    if (jws instanceof Uint8Array) jws = (0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(jws);\n    if (typeof jws !== 'string') throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('Compact JWS must be a string or Uint8Array');\n    const { 0: protectedHeader, 1: payload, 2: signature, length: length } = jws.split('.');\n    if (length !== 3) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('Invalid Compact JWS');\n    const verified = await (0, $0ba0dc1bfe5ab4e3$export$b2614975507c40c9)({\n        payload: payload,\n        protected: protectedHeader,\n        signature: signature\n    }, key, options);\n    const result = {\n        payload: verified.payload,\n        protectedHeader: verified.protectedHeader\n    };\n    if (typeof key === 'function') return {\n        ...result,\n        key: verified.key\n    };\n    return result;\n}\n\n\n\n\nvar $1d5fbb01a516e177$export$2e2bcd8739ae039 = (date)=>Math.floor(date.getTime() / 1000);\n\n\nconst $b19a8a5260a89a2c$var$minute = 60;\nconst $b19a8a5260a89a2c$var$hour = $b19a8a5260a89a2c$var$minute * 60;\nconst $b19a8a5260a89a2c$var$day = $b19a8a5260a89a2c$var$hour * 24;\nconst $b19a8a5260a89a2c$var$week = $b19a8a5260a89a2c$var$day * 7;\nconst $b19a8a5260a89a2c$var$year = $b19a8a5260a89a2c$var$day * 365.25;\nconst $b19a8a5260a89a2c$var$REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nvar $b19a8a5260a89a2c$export$2e2bcd8739ae039 = (str)=>{\n    const matched = $b19a8a5260a89a2c$var$REGEX.exec(str);\n    if (!matched || matched[4] && matched[1]) throw new TypeError('Invalid time period format');\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch(unit){\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * $b19a8a5260a89a2c$var$minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * $b19a8a5260a89a2c$var$hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * $b19a8a5260a89a2c$var$day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * $b19a8a5260a89a2c$var$week);\n            break;\n        default:\n            numericDate = Math.round(value * $b19a8a5260a89a2c$var$year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') return -numericDate;\n    return numericDate;\n};\n\n\n\nfunction $bdd9e5c53c4a8bf8$var$validateInput(label, input) {\n    if (!Number.isFinite(input)) throw new TypeError(`Invalid ${label} input`);\n    return input;\n}\nconst $bdd9e5c53c4a8bf8$var$normalizeTyp = (value)=>{\n    if (value.includes('/')) return value.toLowerCase();\n    return `application/${value.toLowerCase()}`;\n};\nconst $bdd9e5c53c4a8bf8$var$checkAudiencePresence = (audPayload, audOption)=>{\n    if (typeof audPayload === 'string') return audOption.includes(audPayload);\n    if (Array.isArray(audPayload)) return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    return false;\n};\nfunction $bdd9e5c53c4a8bf8$export$c1dedfbfe8124468(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse((0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(encodedPayload));\n    } catch  {}\n    if (!(0, $d42659f8a5b8d03b$export$2e2bcd8739ae039)(payload)) throw new (0, $fcb0a4d5ffcfa358$export$936b39ada0bbfceb)('JWT Claims Set must be a top-level JSON object');\n    const { typ: typ } = options;\n    if (typ && (typeof protectedHeader.typ !== 'string' || $bdd9e5c53c4a8bf8$var$normalizeTyp(protectedHeader.typ) !== $bdd9e5c53c4a8bf8$var$normalizeTyp(typ))) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    const { requiredClaims: requiredClaims = [], issuer: issuer, subject: subject, audience: audience, maxTokenAge: maxTokenAge } = options;\n    const presenceCheck = [\n        ...requiredClaims\n    ];\n    if (maxTokenAge !== undefined) presenceCheck.push('iat');\n    if (audience !== undefined) presenceCheck.push('aud');\n    if (subject !== undefined) presenceCheck.push('sub');\n    if (issuer !== undefined) presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())){\n        if (!(claim in payload)) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n    }\n    if (issuer && !(Array.isArray(issuer) ? issuer : [\n        issuer\n    ]).includes(payload.iss)) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    if (subject && payload.sub !== subject) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    if (audience && !$bdd9e5c53c4a8bf8$var$checkAudiencePresence(payload.aud, typeof audience === 'string' ? [\n        audience\n    ] : audience)) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    let tolerance;\n    switch(typeof options.clockTolerance){\n        case 'string':\n            tolerance = (0, $b19a8a5260a89a2c$export$2e2bcd8739ae039)(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate: currentDate } = options;\n    const now = (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        if (payload.nbf > now + tolerance) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        if (payload.exp <= now - tolerance) throw new (0, $fcb0a4d5ffcfa358$export$4b386bf852b7863d)('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : (0, $b19a8a5260a89a2c$export$2e2bcd8739ae039)(maxTokenAge);\n        if (age - tolerance > max) throw new (0, $fcb0a4d5ffcfa358$export$4b386bf852b7863d)('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        if (age < 0 - tolerance) throw new (0, $fcb0a4d5ffcfa358$export$f1e14efb908196e9)('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n    }\n    return payload;\n}\nclass $bdd9e5c53c4a8bf8$export$9c6bf12f242b7954 {\n    #payload;\n    constructor(payload){\n        if (!(0, $d42659f8a5b8d03b$export$2e2bcd8739ae039)(payload)) throw new TypeError('JWT Claims Set MUST be an object');\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') this.#payload.nbf = $bdd9e5c53c4a8bf8$var$validateInput('setNotBefore', value);\n        else if (value instanceof Date) this.#payload.nbf = $bdd9e5c53c4a8bf8$var$validateInput('setNotBefore', (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(value));\n        else this.#payload.nbf = (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(new Date()) + (0, $b19a8a5260a89a2c$export$2e2bcd8739ae039)(value);\n    }\n    set exp(value) {\n        if (typeof value === 'number') this.#payload.exp = $bdd9e5c53c4a8bf8$var$validateInput('setExpirationTime', value);\n        else if (value instanceof Date) this.#payload.exp = $bdd9e5c53c4a8bf8$var$validateInput('setExpirationTime', (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(value));\n        else this.#payload.exp = (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(new Date()) + (0, $b19a8a5260a89a2c$export$2e2bcd8739ae039)(value);\n    }\n    set iat(value) {\n        if (typeof value === 'undefined') this.#payload.iat = (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(new Date());\n        else if (value instanceof Date) this.#payload.iat = $bdd9e5c53c4a8bf8$var$validateInput('setIssuedAt', (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(value));\n        else if (typeof value === 'string') this.#payload.iat = $bdd9e5c53c4a8bf8$var$validateInput('setIssuedAt', (0, $1d5fbb01a516e177$export$2e2bcd8739ae039)(new Date()) + (0, $b19a8a5260a89a2c$export$2e2bcd8739ae039)(value));\n        else this.#payload.iat = $bdd9e5c53c4a8bf8$var$validateInput('setIssuedAt', value);\n    }\n}\n\n\n\nasync function $63cfaa914d2a7434$export$c878fd0f8381da51(jwt, key, options) {\n    const verified = await (0, $34b21a43c46da8fc$export$996150e72a8992e)(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) throw new (0, $fcb0a4d5ffcfa358$export$936b39ada0bbfceb)('JWTs MUST NOT use unencoded payload');\n    const payload = (0, $bdd9e5c53c4a8bf8$export$c1dedfbfe8124468)(verified.protectedHeader, verified.payload, options);\n    const result = {\n        payload: payload,\n        protectedHeader: verified.protectedHeader\n    };\n    if (typeof key === 'function') return {\n        ...result,\n        key: verified.key\n    };\n    return result;\n}\n\n\n\n\n\nvar $c74b42bc9cd68474$export$2e2bcd8739ae039 = async (alg, key, data)=>{\n    const cryptoKey = await (0, $808a0a0b4110568f$export$2e2bcd8739ae039)(alg, key, 'sign');\n    (0, $a0928e387ca12497$export$2e2bcd8739ae039)(alg, cryptoKey);\n    const signature = await crypto.subtle.sign((0, $b931fa48b21a7ebb$export$2e2bcd8739ae039)(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n\n\n\n\n\n\n\n\nclass $3295f05bb1e2894c$export$9a8af5200da5ddb1 {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload){\n        if (!(payload instanceof Uint8Array)) throw new TypeError('payload must be an instance of Uint8Array');\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) throw new TypeError('setProtectedHeader can only be called once');\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) throw new TypeError('setUnprotectedHeader can only be called once');\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        if (!(0, $d4e8ade71e394405$export$2e2bcd8739ae039)(this.#protectedHeader, this.#unprotectedHeader)) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader\n        };\n        const extensions = (0, $0feff00fbaa58163$export$2e2bcd8739ae039)((0, $fcb0a4d5ffcfa358$export$e838de724af3d116), new Map([\n            [\n                'b64',\n                true\n            ]\n        ]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n        const { alg: alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) throw new (0, $fcb0a4d5ffcfa358$export$e838de724af3d116)('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        (0, $4de7699679ffccc9$export$2e2bcd8739ae039)(alg, key, 'sign');\n        let payload = this.#payload;\n        if (b64) payload = (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode((0, $e4060018315ad9ee$export$c564cdbbe6da493)(payload));\n        let protectedHeader;\n        if (this.#protectedHeader) protectedHeader = (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode((0, $e4060018315ad9ee$export$c564cdbbe6da493)(JSON.stringify(this.#protectedHeader)));\n        else protectedHeader = (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode('');\n        const data = (0, $1e53c4773f96b7ed$export$ee1b3e54f0441b22)(protectedHeader, (0, $1e53c4773f96b7ed$export$5486af06137bf21a).encode('.'), payload);\n        const k = await (0, $cfbcd9d6853dac90$export$2e2bcd8739ae039)(key, alg);\n        const signature = await (0, $c74b42bc9cd68474$export$2e2bcd8739ae039)(alg, k, data);\n        const jws = {\n            signature: (0, $e4060018315ad9ee$export$c564cdbbe6da493)(signature),\n            payload: ''\n        };\n        if (b64) jws.payload = (0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(payload);\n        if (this.#unprotectedHeader) jws.header = this.#unprotectedHeader;\n        if (this.#protectedHeader) jws.protected = (0, $1e53c4773f96b7ed$export$124c96e6ce37090b).decode(protectedHeader);\n        return jws;\n    }\n}\n\n\nclass $cb14518c5aca8e57$export$b6738d8e70498d17 {\n    #flattened;\n    constructor(payload){\n        this.#flattened = new (0, $3295f05bb1e2894c$export$9a8af5200da5ddb1)(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) throw new TypeError('use the flattened module for creating JWS with b64: false');\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n\n\n\n\nclass $e2771f1c4a96400e$export$88d4e5d23fbe6c84 {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}){\n        this.#jwt = new (0, $bdd9e5c53c4a8bf8$export$9c6bf12f242b7954)(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new (0, $cb14518c5aca8e57$export$b6738d8e70498d17)(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) && this.#protectedHeader.crit.includes('b64') && this.#protectedHeader.b64 === false) throw new (0, $fcb0a4d5ffcfa358$export$936b39ada0bbfceb)('JWTs MUST NOT use unencoded payload');\n        return sig.sign(key, options);\n    }\n}\n\n\nfunction $e41686720d7d0552$export$9e15fb06e64c4810(length) {\n    let ret = '';\n    while(ret.length < length){\n        // Generate a random number, convert to base 36, remove the '0.' prefix\n        let value = Math.random().toString(36).substring(2);\n        ret += value;\n    }\n    return ret.substring(0, length);\n}\nfunction $e41686720d7d0552$export$427b77783060a5c0() {\n    // Current timestamp in milliseconds converted to base 36\n    const timestampPart = Date.now().toString(36);\n    const randomPart = $e41686720d7d0552$export$9e15fb06e64c4810(22);\n    return `${timestampPart}${randomPart}`;\n}\n\n\nfunction $b278ac87db33fd91$export$bf81b77f696942c6({ projectId: projectId, projectSecret: projectSecret }) {\n    const BASE_URL = 'https://revenue.ezboti.com/api/v1/server';\n    const self = {\n        async decodeToken (token) {\n            const secret = new TextEncoder().encode(projectSecret);\n            const { payload: payload } = await (0, $63cfaa914d2a7434$export$c878fd0f8381da51)(token, secret);\n            return payload.result;\n        },\n        async encodeToken (payload) {\n            payload.exp = Date.now() + 1800 // +30\n            ;\n            payload.nonce = (0, $e41686720d7d0552$export$9e15fb06e64c4810)(16) // 32\n            ;\n            const secret = new TextEncoder().encode(projectSecret);\n            const jwt = new (0, $e2771f1c4a96400e$export$88d4e5d23fbe6c84)(payload).setProtectedHeader({\n                alg: 'HS256',\n                project_id: projectId\n            });\n            const token = await jwt.sign(secret);\n            return token;\n        },\n        sendRequest ({ url: url, content: content }) {\n            return fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'text/plain'\n                },\n                body: content\n            });\n        },\n        async call (api, params) {\n            const token = await self.encodeToken({\n                method: api,\n                params: params\n            });\n            const url = BASE_URL + '/' + api;\n            try {\n                let response = await self.sendRequest({\n                    url: url,\n                    content: token\n                });\n                let text = await response.text();\n                return await self.decodeToken(text);\n            } catch (error) {\n                if (error.response) {\n                    const { status: status, data: data } = error.response;\n                    console.log(`${api} failed status=${status}, body ==>`, data);\n                }\n                throw error;\n            }\n        }\n    };\n    return self;\n}\n\n\n\nfunction $40c55c056137eedc$export$110613c1b3c79966({ prefix: prefix, storageKey: storageKey } = {}) {\n    prefix = prefix || '';\n    storageKey = storageKey || 'ezrevenueDeviceId';\n    /**\n   * ID\n   * @returns {Promise<string>} ID\n   * @description chrome.storage.localIDID\n   */ async function getOrCreateDeviceId() {\n        const data = await chrome.storage.local.get(storageKey);\n        let deviceId = data[storageKey];\n        if (!deviceId) {\n            deviceId = prefix + (0, $e41686720d7d0552$export$427b77783060a5c0)();\n            console.log(`create deviceId ${deviceId}`);\n            await chrome.storage.local.set({\n                [storageKey]: deviceId\n            });\n        } else console.log(`get deviceId ${deviceId}`);\n        return deviceId;\n    }\n    return getOrCreateDeviceId;\n}\nfunction $40c55c056137eedc$export$7817c030a0c52233({ projectId: projectId, projectSecret: projectSecret, paywallAlias: paywallAlias, customerIdGetter: customerIdGetter }) {\n    paywallAlias = paywallAlias || 'paywall_vip';\n    if (!customerIdGetter) customerIdGetter = $40c55c056137eedc$export$110613c1b3c79966();\n    // \n    const state = {\n        customerInfo: null,\n        lastChecked: null\n    };\n    /**\n   * ()\n   * @param {Object} request \n   * @param {boolean} [request.refresh] \n   * @returns {Promise<Object>} :\n   *   - success: boolean \n   *   - data: Object ()\n   *   - error: string ()\n   */ async function getCustomerInfo(request) {\n        try {\n            const customerInfo = await getCustomerInfoAsync(request);\n            return {\n                success: true,\n                data: customerInfo\n            };\n        } catch (err) {\n            return {\n                success: false,\n                error: err.message || err\n            };\n        }\n    }\n    /**\n   * ()\n   * @param {Object} request \n   * @param {boolean} [request.refresh] \n   * @returns {Promise<Object>} \n   * @description 30\n   */ async function getCustomerInfoAsync(request) {\n        if (request.refresh) {\n            state.customerInfo = null;\n            state.lastChecked = null;\n        }\n        if (state.customerInfo) {\n            let lastChecked = state.lastChecked;\n            let isExpired = Date.now() - lastChecked > 1800000;\n            if (!lastChecked || isExpired) {\n                state.customerInfo = null;\n                state.lastChecked = null;\n            }\n        }\n        if (!state.customerInfo) {\n            state.customerInfo = await getCustomerInfoImpl();\n            state.lastChecked = Date.now();\n        }\n        return state.customerInfo;\n    }\n    /**\n   * API\n   * @returns {Promise<Object>} \n   * @throws {Error} API\n   * @description VIP\n   */ async function getCustomerInfoImpl() {\n        let client = (0, $b278ac87db33fd91$export$bf81b77f696942c6)({\n            projectId: projectId,\n            projectSecret: projectSecret\n        });\n        let deviceId = await customerIdGetter();\n        let res = await client.call('customer.info', {\n            paywall_alias: paywallAlias,\n            customer: {\n                external_id: deviceId\n            },\n            include_balance: true\n        });\n        console.log('customerInfo', res);\n        return res;\n    }\n    /**\n   * popup/content script\n   * :\n   * - getCustomerInfo: \n   */ chrome.runtime.onMessage.addListener((request, sender, sendResponse)=>{\n        const handlerMap = {\n            ezrevenue_customer_info: getCustomerInfo\n        };\n        let handlerFunc = handlerMap[request.action];\n        if (handlerFunc) {\n            handlerFunc(request).then(sendResponse);\n            return true;\n        }\n    });\n}\n\n\nexport {$40c55c056137eedc$export$110613c1b3c79966 as createDeviceIdGetter, $40c55c056137eedc$export$7817c030a0c52233 as registerEzrevenueBackground};\n//# sourceMappingURL=background.js.map\n","import { EzrevenueClient } from './ezrevenue.js'\nimport { generateDeviceUniqueId } from './stringRandom.js'\n\nexport function createDeviceIdGetter({ prefix, storageKey } = {}) {\n  prefix = prefix || ''\n  storageKey = storageKey || 'ezrevenueDeviceId'\n  /**\n   * ID\n   * @returns {Promise<string>} ID\n   * @description chrome.storage.localIDID\n   */\n  async function getOrCreateDeviceId() {\n    const data = await chrome.storage.local.get(storageKey)\n    let deviceId = data[storageKey]\n    if (!deviceId) {\n      deviceId = prefix + generateDeviceUniqueId()\n      console.log(`create deviceId ${deviceId}`)\n      await chrome.storage.local.set({ [storageKey]: deviceId })\n    } else {\n      console.log(`get deviceId ${deviceId}`)\n    }\n    return deviceId\n  }\n  return getOrCreateDeviceId\n}\n\nexport function registerEzrevenueBackground({\n  projectId,\n  projectSecret,\n  paywallAlias,\n  customerIdGetter,\n}) {\n  paywallAlias = paywallAlias || 'paywall_vip'\n  if (!customerIdGetter) {\n    customerIdGetter = createDeviceIdGetter()\n  }\n\n  // \n  const state = {\n    customerInfo: null,\n    lastChecked: null,\n  }\n\n  /**\n   * ()\n   * @param {Object} request \n   * @param {boolean} [request.refresh] \n   * @returns {Promise<Object>} :\n   *   - success: boolean \n   *   - data: Object ()\n   *   - error: string ()\n   */\n  async function getCustomerInfo(request) {\n    try {\n      const customerInfo = await getCustomerInfoAsync(request)\n      return {\n        success: true,\n        data: customerInfo,\n      }\n    } catch (err) {\n      return {\n        success: false,\n        error: err.message || err,\n      }\n    }\n  }\n\n  /**\n   * ()\n   * @param {Object} request \n   * @param {boolean} [request.refresh] \n   * @returns {Promise<Object>} \n   * @description 30\n   */\n  async function getCustomerInfoAsync(request) {\n    if (request.refresh) {\n      state.customerInfo = null\n      state.lastChecked = null\n    }\n    if (state.customerInfo) {\n      let lastChecked = state.lastChecked\n      let isExpired = Date.now() - lastChecked > 30 * 60 * 1000\n      if (!lastChecked || isExpired) {\n        state.customerInfo = null\n        state.lastChecked = null\n      }\n    }\n    if (!state.customerInfo) {\n      state.customerInfo = await getCustomerInfoImpl()\n      state.lastChecked = Date.now()\n    }\n    return state.customerInfo\n  }\n\n  /**\n   * API\n   * @returns {Promise<Object>} \n   * @throws {Error} API\n   * @description VIP\n   */\n  async function getCustomerInfoImpl() {\n    let client = EzrevenueClient({\n      projectId: projectId,\n      projectSecret: projectSecret,\n    })\n    let deviceId = await customerIdGetter()\n    let res = await client.call('customer.info', {\n      paywall_alias: paywallAlias,\n      customer: {\n        external_id: deviceId,\n      },\n      include_balance: true,\n    })\n    console.log('customerInfo', res)\n    return res\n  }\n\n  /**\n   * popup/content script\n   * :\n   * - getCustomerInfo: \n   */\n  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    const handlerMap = {\n      ezrevenue_customer_info: getCustomerInfo,\n    }\n    let handlerFunc = handlerMap[request.action]\n    if (handlerFunc) {\n      handlerFunc(request).then(sendResponse)\n      return true\n    }\n  })\n}\n","import { SignJWT, jwtVerify } from 'jose'\nimport { generateRandomString } from './stringRandom.js'\n\nexport function EzrevenueClient({ projectId, projectSecret }) {\n  const BASE_URL = 'https://revenue.ezboti.com/api/v1/server'\n  const self = {\n    async decodeToken(token) {\n      const secret = new TextEncoder().encode(projectSecret)\n      const { payload } = await jwtVerify(token, secret)\n      return payload.result\n    },\n    async encodeToken(payload) {\n      payload.exp = Date.now() + 30 * 60 // +30\n      payload.nonce = generateRandomString(16) // 32\n      const secret = new TextEncoder().encode(projectSecret)\n      const jwt = new SignJWT(payload).setProtectedHeader({\n        alg: 'HS256',\n        project_id: projectId,\n      })\n      const token = await jwt.sign(secret)\n      return token\n    },\n    sendRequest({ url, content }) {\n      return fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'text/plain',\n        },\n        body: content,\n      })\n    },\n    async call(api, params) {\n      const token = await self.encodeToken({ method: api, params: params })\n      const url = BASE_URL + '/' + api\n      try {\n        let response = await self.sendRequest({ url, content: token })\n        let text = await response.text()\n        return await self.decodeToken(text)\n      } catch (error) {\n        if (error.response) {\n          const { status, data } = error.response\n          console.log(`${api} failed status=${status}, body ==>`, data)\n        }\n        throw error\n      }\n    },\n  }\n  return self\n}\n","import { compactVerify } from '../jws/compact/verify.js';\nimport { validateClaimsSet } from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    const verified = await compactVerify(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { decode as b64u } from '../../util/base64url.js';\nimport verify from '../../lib/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nimport normalizeKey from '../../lib/normalize_key.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = b64u(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = b64u(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const k = await normalizeKey(key, alg);\n    const verified = await verify(alg, k, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = b64u(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key: k };\n    }\n    return result;\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\n","export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n","import subtleAlgorithm from './subtle_dsa.js';\nimport checkKeyLength from './check_key_length.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nexport default async (alg, key, signature, data) => {\n    const cryptoKey = await getVerifyKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch {\n        return false;\n    }\n};\n","import { JOSENotSupported } from '../util/errors.js';\nexport default (alg, algorithm) => {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: parseInt(alg.slice(-3), 10) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n        case 'EdDSA':\n            return { name: 'Ed25519' };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n};\n","export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n","export default (alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n","import { checkSigCryptoKey } from './crypto_key.js';\nimport invalidKeyInput from './invalid_key_input.js';\nexport default async (alg, key, usage) => {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    checkSigCryptoKey(key, alg, usage);\n    return key;\n};\n","function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) {\n        throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n    }\n}\nexport function checkSigCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\nexport function checkEncCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw unusable('ECDH or X25519');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n","export default (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default (input) => {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n};\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike from './is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined) {\n        let expected;\n        switch (usage) {\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) {\n            throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n        }\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    }\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch (true) {\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) {\n                    expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                }\n                else {\n                    expectedKeyOp = usage;\n                }\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {\n            throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n        }\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (jwk.isJWK(key)) {\n        switch (usage) {\n            case 'decrypt':\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'encrypt':\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (key.type === 'public') {\n        switch (usage) {\n            case 'sign':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n            case 'decrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n            default:\n                break;\n        }\n    }\n    if (key.type === 'private') {\n        switch (usage) {\n            case 'verify':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n            case 'encrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n            default:\n                break;\n        }\n    }\n};\nexport default (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(alg) ||\n        /^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key, usage);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\n","export function assertCryptoKey(key) {\n    if (!isCryptoKey(key)) {\n        throw new Error('CryptoKey instance expected');\n    }\n}\nexport function isCryptoKey(key) {\n    return key?.[Symbol.toStringTag] === 'CryptoKey';\n}\nexport function isKeyObject(key) {\n    return key?.[Symbol.toStringTag] === 'KeyObject';\n}\nexport default (key) => {\n    return isCryptoKey(key) || isKeyObject(key);\n};\n","import isObject from './is_object.js';\nexport function isJWK(key) {\n    return isObject(key) && typeof key.kty === 'string';\n}\nexport function isPrivateJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'string';\n}\nexport function isPublicJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'undefined';\n}\nexport function isSecretJWK(key) {\n    return key.kty === 'oct' && typeof key.k === 'string';\n}\n","import { JOSENotSupported, JWEInvalid, JWSInvalid } from '../util/errors.js';\nexport default (Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) => {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n};\n","export default (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\n","import { isJWK } from './is_jwk.js';\nimport { decode } from '../util/base64url.js';\nimport importJWK from './jwk_to_key.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nlet cache;\nconst handleJWK = async (key, jwk, alg, freeze = false) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await importJWK({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst handleKeyObject = (keyObject, alg) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(keyObject);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch (alg) {\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ['deriveBits']);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign',\n        ]);\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch (alg) {\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) {\n            return keyObject.toCryptoKey({\n                name: 'RSA-OAEP',\n                hash,\n            }, extractable, isPublic ? ['encrypt'] : ['decrypt']);\n        }\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash,\n        }, extractable, [isPublic ? 'verify' : 'sign']);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            ['prime256v1', 'P-256'],\n            ['secp384r1', 'P-384'],\n            ['secp521r1', 'P-521'],\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg === 'ES256' && namedCurve === 'P-256') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES384' && namedCurve === 'P-384') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES512' && namedCurve === 'P-521') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg.startsWith('ECDH-ES')) {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDH',\n                namedCurve,\n            }, extractable, isPublic ? [] : ['deriveBits']);\n        }\n    }\n    if (!cryptoKey) {\n        throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    }\n    if (!cached) {\n        cache.set(keyObject, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nexport default async (key, alg) => {\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            return key.export();\n        }\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') {\n            try {\n                return handleKeyObject(key, alg);\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n            }\n        }\n        let jwk = key.export({ format: 'jwk' });\n        return handleJWK(key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k) {\n            return decode(key.k);\n        }\n        return handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n};\n","import { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nexport default async (jwk) => {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d ? false : true), jwk.key_ops ?? keyUsages);\n};\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nimport { encoder } from './buffer_utils.js';\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nconst normalizeTyp = (value) => {\n    if (value.includes('/')) {\n        return value.toLowerCase();\n    }\n    return `application/${value.toLowerCase()}`;\n};\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n}\nexport class JWTClaimsBuilder {\n    #payload;\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return encoder.encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') {\n            this.#payload.nbf = validateInput('setNotBefore', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.nbf = validateInput('setNotBefore', epoch(value));\n        }\n        else {\n            this.#payload.nbf = epoch(new Date()) + secs(value);\n        }\n    }\n    set exp(value) {\n        if (typeof value === 'number') {\n            this.#payload.exp = validateInput('setExpirationTime', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.exp = validateInput('setExpirationTime', epoch(value));\n        }\n        else {\n            this.#payload.exp = epoch(new Date()) + secs(value);\n        }\n    }\n    set iat(value) {\n        if (typeof value === 'undefined') {\n            this.#payload.iat = epoch(new Date());\n        }\n        else if (value instanceof Date) {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(value));\n        }\n        else if (typeof value === 'string') {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(new Date()) + secs(value));\n        }\n        else {\n            this.#payload.iat = validateInput('setIssuedAt', value);\n        }\n    }\n}\n","export default (date) => Math.floor(date.getTime() / 1000);\n","const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","import { encode as b64u } from '../../util/base64url.js';\nimport sign from '../../lib/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport normalizeKey from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this.#payload;\n        if (b64) {\n            payload = encoder.encode(b64u(payload));\n        }\n        let protectedHeader;\n        if (this.#protectedHeader) {\n            protectedHeader = encoder.encode(b64u(JSON.stringify(this.#protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n","import subtleAlgorithm from './subtle_dsa.js';\nimport checkKeyLength from './check_key_length.js';\nimport getSignKey from './get_sign_verify_key.js';\nexport default async (alg, key, data) => {\n    const cryptoKey = await getSignKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n","export function generateRandomString(length) {\n  let ret = ''\n  while (ret.length < length) {\n    // Generate a random number, convert to base 36, remove the '0.' prefix\n    let value = Math.random().toString(36).substring(2)\n    ret += value\n  }\n  return ret.substring(0, length)\n}\n\nexport function generateDeviceUniqueId() {\n  // Current timestamp in milliseconds converted to base 36\n  const timestampPart = Date.now().toString(36)\n  const randomPart = generateRandomString(22)\n  return `${timestampPart}${randomPart}`\n}\n"],"names":["$cfbcd9d6853dac90$var$cache","$1e53c4773f96b7ed$export$5486af06137bf21a","TextEncoder","$1e53c4773f96b7ed$export$124c96e6ce37090b","TextDecoder","$1e53c4773f96b7ed$export$ee1b3e54f0441b22","buffers","buf","Uint8Array","reduce","acc","length","i","buffer","set","$e4060018315ad9ee$export$2f872c0f2117be69","input","fromBase64","decode","alphabet","encoded","replace","binary","atob","bytes","charCodeAt","TypeError","$e4060018315ad9ee$export$c564cdbbe6da493","unencoded","encode","prototype","toBase64","omitPadding","arr","push","String","fromCharCode","apply","subarray","btoa","join","$fcb0a4d5ffcfa358$export$f754d6850d76bf87","Error","code","constructor","message","options","name","captureStackTrace","$fcb0a4d5ffcfa358$export$f1e14efb908196e9","claim","reason","payload","cause","$fcb0a4d5ffcfa358$export$4b386bf852b7863d","$fcb0a4d5ffcfa358$export$d51fd7fedeccc338","$fcb0a4d5ffcfa358$export$19ddbcbf2016ab28","$fcb0a4d5ffcfa358$export$e838de724af3d116","$fcb0a4d5ffcfa358$export$936b39ada0bbfceb","$fcb0a4d5ffcfa358$export$dc036de401a5c284","Symbol","asyncIterator","$fcb0a4d5ffcfa358$export$c67a0218e7c50378","$b931fa48b21a7ebb$export$2e2bcd8739ae039","alg","algorithm","hash","slice","saltLength","parseInt","namedCurve","$a0928e387ca12497$export$2e2bcd8739ae039","key","startsWith","modulusLength","$9bc1a6ef4e16e750$var$unusable","prop","$9bc1a6ef4e16e750$var$isAlgorithm","$9bc1a6ef4e16e750$var$getHashLength","$abe2cc4bd17085c3$var$message","msg","actual","types","filter","Boolean","last","pop","$abe2cc4bd17085c3$export$2e2bcd8739ae039","$abe2cc4bd17085c3$export$e94f758d09bc1828","$808a0a0b4110568f$export$2e2bcd8739ae039","usage","crypto","subtle","importKey","expected","$9bc1a6ef4e16e750$var$getNamedCurve","usages","includes","$3020225b8bd97811$export$2e2bcd8739ae039","signature","data","cryptoKey","verify","$d4e8ade71e394405$export$2e2bcd8739ae039","headers","sources","header","parameters","Object","keys","size","Set","parameter","has","add","$d42659f8a5b8d03b$export$2e2bcd8739ae039","value","toString","call","getPrototypeOf","proto","$b5aa186e9118266c$export$600b5603bbac4c6","toStringTag","$b5aa186e9118266c$export$5c7abba3d2afc0b8","$b5aa186e9118266c$export$2e2bcd8739ae039","$1635c73958ea941f$export$9a44c2ef7e3b3dad","kty","$4de7699679ffccc9$var$tag","$4de7699679ffccc9$var$jwkMatchesOp","undefined","use","Array","isArray","key_ops","expectedKeyOp","test","endsWith","$4de7699679ffccc9$var$symmetricTypeCheck","$1635c73958ea941f$export$f8ecf533504bc7ad","k","type","$4de7699679ffccc9$var$asymmetricTypeCheck","$1635c73958ea941f$export$431699a4f17ba0e","d","$1635c73958ea941f$export$b786616db1cddf3","$4de7699679ffccc9$export$2e2bcd8739ae039","$0feff00fbaa58163$export$2e2bcd8739ae039","Err","recognizedDefault","recognizedOption","protectedHeader","joseHeader","recognized","crit","some","Map","entries","get","$7001990ad23a4387$export$2e2bcd8739ae039","option","algorithms","s","$8c122fdfc9a37024$export$2e2bcd8739ae039","jwk","keyUsages","$8c122fdfc9a37024$var$subtleMapping","crv","keyData","ext","$cfbcd9d6853dac90$var$handleJWK","freeze","cached","WeakMap","$cfbcd9d6853dac90$var$handleKeyObject","keyObject","isPublic","extractable","asymmetricKeyType","toCryptoKey","nist","asymmetricKeyDetails","$cfbcd9d6853dac90$export$2e2bcd8739ae039","export","err","format","$0ba0dc1bfe5ab4e3$export$b2614975507c40c9","jws","protected","parsedProt","JSON","parse","extensions","b64","resolvedKey","result","unprotectedHeader","$34b21a43c46da8fc$export$996150e72a8992e","split","verified","$1d5fbb01a516e177$export$2e2bcd8739ae039","date","Math","floor","getTime","$b19a8a5260a89a2c$var$REGEX","$b19a8a5260a89a2c$export$2e2bcd8739ae039","str","numericDate","matched","exec","parseFloat","toLowerCase","round","$b19a8a5260a89a2c$var$minute","$b19a8a5260a89a2c$var$hour","$b19a8a5260a89a2c$var$day","$bdd9e5c53c4a8bf8$var$validateInput","label","Number","isFinite","$bdd9e5c53c4a8bf8$var$normalizeTyp","$bdd9e5c53c4a8bf8$var$checkAudiencePresence","audPayload","audOption","bind","$bdd9e5c53c4a8bf8$export$9c6bf12f242b7954","structuredClone","stringify","iss","sub","aud","jti","nbf","Date","exp","iat","$63cfaa914d2a7434$export$c878fd0f8381da51","jwt","encodedPayload","tolerance","typ","requiredClaims","issuer","subject","audience","maxTokenAge","presenceCheck","reverse","clockTolerance","currentDate","now","age","$c74b42bc9cd68474$export$2e2bcd8739ae039","sign","$3295f05bb1e2894c$export$9a8af5200da5ddb1","setProtectedHeader","setUnprotectedHeader","$cb14518c5aca8e57$export$b6738d8e70498d17","$e2771f1c4a96400e$export$88d4e5d23fbe6c84","setIssuer","setSubject","setAudience","setJti","jwtId","setNotBefore","setExpirationTime","setIssuedAt","sig","$e41686720d7d0552$export$9e15fb06e64c4810","ret","random","substring","$40c55c056137eedc$export$110613c1b3c79966","prefix","storageKey","deviceId","chrome","storage","local","console","log","timestampPart","randomPart","$40c55c056137eedc$export$7817c030a0c52233","projectId","projectSecret","paywallAlias","customerIdGetter","state","customerInfo","lastChecked","getCustomerInfo","request","getCustomerInfoAsync","success","error","refresh","isExpired","getCustomerInfoImpl","client","self","decodeToken","token","secret","encodeToken","nonce","project_id","sendRequest","url","content","fetch","method","body","api","params","response","BASE_URL","text","status","res","paywall_alias","customer","external_id","include_balance","runtime","onMessage","addListener","sender","sendResponse","handlerFunc","handlerMap","ezrevenue_customer_info","action","then","createDeviceIdGetter","registerEzrevenueBackground"],"version":3,"file":"background.js.map"}